/**
 * Code Protection & Obfuscation
 * 
 * Protects source code from modification by:
 * 1. File integrity checks (SHA-256 hashes)
 * 2. Read-only mode in production
 * 3. Tamper detection
 * 4. AI/LLM detection (blocks ChatGPT/Claude/Cursor attempts)
 */

import * as crypto from "crypto";
import * as fs from "fs/promises";
import * as path from "path";
import { logger } from "../core/logger.js";

const log = logger.child("CodeProtection");

export interface FileIntegrity {
  filePath: string;
  hash: string;
  size: number;
  timestamp: string;
}

export class CodeProtectionService {
  private integrityMap: Map<string, FileIntegrity> = new Map();
  private protectedPaths: string[] = [];
  private isProduction: boolean;

  constructor(protectedPaths: string[] = []) {
    this.protectedPaths = protectedPaths;
    this.isProduction = process.env.NODE_ENV === "production";
  }

  /**
   * Generate SHA-256 hash of file content
   */
  private async generateFileHash(filePath: string): Promise<string> {
    const content = await fs.readFile(filePath);
    return crypto.createHash("sha256").update(content).digest("hex");
  }

  /**
   * Initialize integrity checks for all protected files
   */
  async initializeIntegrityChecks(): Promise<void> {
    if (!this.isProduction) {
      log.info("Code protection disabled in development mode");
      return;
    }

    log.info(`Initializing code protection for ${this.protectedPaths.length} paths`);

    for (const basePath of this.protectedPaths) {
      await this.scanDirectory(basePath);
    }

    log.info(`Code protection initialized: ${this.integrityMap.size} files protected`);
  }

  /**
   * Recursively scan directory and calculate hashes
   */
  private async scanDirectory(dirPath: string): Promise<void> {
    try {
      const stats = await fs.stat(dirPath);

      if (stats.isDirectory()) {
        const entries = await fs.readdir(dirPath);
        for (const entry of entries) {
          // Skip node_modules, .git, dist, etc
          if (entry === "node_modules" || entry === ".git" || entry === "dist" || entry.startsWith(".")) {
            continue;
          }

          await this.scanDirectory(path.join(dirPath, entry));
        }
      } else if (stats.isFile()) {
        // Only protect source files
        const ext = path.extname(dirPath);
        if ([".ts", ".js", ".json"].includes(ext)) {
          const hash = await this.generateFileHash(dirPath);
          this.integrityMap.set(dirPath, {
            filePath: dirPath,
            hash,
            size: stats.size,
            timestamp: stats.mtime.toISOString(),
          });
        }
      }
    } catch (error: any) {
      log.warn(`Failed to scan ${dirPath}`, error);
    }
  }

  /**
   * Verify file integrity (detect tampering)
   */
  async verifyFileIntegrity(filePath: string): Promise<{ valid: boolean; reason?: string }> {
    if (!this.isProduction) {
      return { valid: true };
    }

    const stored = this.integrityMap.get(filePath);
    if (!stored) {
      return { valid: false, reason: "File not in protection list" };
    }

    try {
      const currentHash = await this.generateFileHash(filePath);

      if (currentHash !== stored.hash) {
        log.error(`ðŸš¨ FILE TAMPERED: ${filePath}`, {
          expectedHash: stored.hash,
          actualHash: currentHash,
        });

        return { valid: false, reason: "File has been modified (hash mismatch)" };
      }

      return { valid: true };
    } catch (error: any) {
      return { valid: false, reason: `Verification error: ${error.message}` };
    }
  }

  /**
   * Periodic integrity check (runs every hour in production)
   */
  async runIntegrityCheck(): Promise<{ totalFiles: number; tamperedFiles: string[] }> {
    if (!this.isProduction) {
      return { totalFiles: 0, tamperedFiles: [] };
    }

    const tamperedFiles: string[] = [];

    for (const [filePath, stored] of this.integrityMap.entries()) {
      const result = await this.verifyFileIntegrity(filePath);
      if (!result.valid) {
        tamperedFiles.push(filePath);
      }
    }

    if (tamperedFiles.length > 0) {
      log.error(`ðŸš¨ INTEGRITY BREACH: ${tamperedFiles.length} files tampered`, {
        tamperedFiles,
      });
    }

    return {
      totalFiles: this.integrityMap.size,
      tamperedFiles,
    };
  }

  /**
   * Detect AI/LLM code modification attempts
   * 
   * Checks for common AI-generated patterns:
   * - ChatGPT signatures
   * - Claude signatures
   * - Cursor AI patterns
   * - Generic AI comments
   */
  detectAIModification(code: string): { isAI: boolean; confidence: number; patterns: string[] } {
    const aiPatterns = [
      // ChatGPT signatures
      /\/\/ Generated by ChatGPT/i,
      /\/\/ AI-generated code/i,
      /\/\/ This code was created by/i,
      
      // Claude signatures
      /\/\/ Claude Assistant/i,
      /\/\/ Anthropic Claude/i,
      
      // Cursor AI
      /\/\/ Cursor AI/i,
      /\/\/ AI Autocomplete/i,
      
      // Generic AI patterns
      /\/\/ TODO: AI suggestion/i,
      /\/\/ AI-powered/i,
      /\/\/ Machine learning generated/i,
      
      // Common AI comment styles
      /\/\/ Here's how to fix this:/i,
      /\/\/ This function does the following:/i,
      /\/\/ Note: This is a suggested implementation/i,
    ];

    const detectedPatterns: string[] = [];
    let matchCount = 0;

    for (const pattern of aiPatterns) {
      if (pattern.test(code)) {
        matchCount++;
        detectedPatterns.push(pattern.source);
      }
    }

    const confidence = Math.min((matchCount / aiPatterns.length) * 100, 100);

    return {
      isAI: matchCount > 0,
      confidence,
      patterns: detectedPatterns,
    };
  }

  /**
   * Block code modifications in production
   */
  async blockModification(filePath: string, reason: string = "Unauthorized modification"): Promise<void> {
    log.error(`ðŸš« BLOCKED MODIFICATION: ${filePath}`, { reason });

    // In production, make file read-only
    if (this.isProduction) {
      try {
        await fs.chmod(filePath, 0o444); // Read-only for all
        log.info(`File locked: ${filePath}`);
      } catch (error: any) {
        log.error(`Failed to lock file ${filePath}`, error);
      }
    }
  }

  /**
   * Export integrity manifest (for customer verification)
   */
  exportManifest(): FileIntegrity[] {
    return Array.from(this.integrityMap.values());
  }

  /**
   * Start periodic integrity checks
   */
  startPeriodicChecks(intervalMinutes: number = 60): void {
    if (!this.isProduction) {
      log.info("Periodic integrity checks disabled in development");
      return;
    }

    setInterval(async () => {
      const result = await this.runIntegrityCheck();
      
      if (result.tamperedFiles.length > 0) {
        log.error(`ðŸš¨ TAMPER ALERT: ${result.tamperedFiles.length} files modified`, {
          files: result.tamperedFiles,
        });
      } else {
        log.info(`âœ… Integrity check passed: ${result.totalFiles} files verified`);
      }
    }, intervalMinutes * 60 * 1000);

    log.info(`Periodic integrity checks enabled (every ${intervalMinutes} minutes)`);
  }
}

// Global instance
export const codeProtection = new CodeProtectionService([
  "./server/src",      // Server code
  "./server/routes.ts", // Routes
  "./server/migrate.ts", // Migrations
  "./shared",          // Shared schemas
]);
